//------------------------------------------------------------------------------
// <auto-generated>
//     Denna kod har genererats av ett verktyg.
//     Körtidsversion:4.0.30319.34014
//
//     Ändringar i denna fil kan orsaka fel och kommer att förloras om
//     koden återgenereras.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System;
using System.Collections.Generic;

public class Pathfinder
{
	private HashSet<Tile> closedList;
	private BinaryHeap<Tile> openList;
	public static Tile endTile;
	public List<Tile> path;

	public Pathfinder (Tile startTile, Tile endTile, HashSet<Tile> moveAbleTiles )
	{
		Pathfinder.endTile=endTile;
		path=new List<Tile>();
		int steps=0;
		closedList=new HashSet<Tile>();
		openList=new BinaryHeap<Tile>();
		Tile currTile=startTile;
		currTile.G=0f;


		while(currTile!=endTile)
		{
			if(closedList.Add(currTile))
			{
				if(moveAbleTiles.Contains(currTile.North) && !closedList.Contains(currTile.North))
				{
					currTile.North.G=currTile.G+(float)currTile.North.Movecost;
					openList.Add(currTile.North);
				}
				if(moveAbleTiles.Contains(currTile.South) && !closedList.Contains(currTile.South))
				{
					currTile.South.G=currTile.G+(float)currTile.South.Movecost;
					openList.Add(currTile.South);
				}
				if(moveAbleTiles.Contains(currTile.East) && !closedList.Contains(currTile.East))
				{
					currTile.East.G=currTile.G+(float)currTile.East.Movecost;
					openList.Add(currTile.East);
				}
				if(moveAbleTiles.Contains(currTile.West) && !closedList.Contains(currTile.West))
				{
					currTile.West.G=currTile.G+(float)currTile.West.Movecost;
					openList.Add(currTile.West);
				}
			}
			if(openList.Count > 0)
				currTile=openList.Remove();
			else{
				Debug.LogError("No Path Found between " + startTile + " & " + endTile);
				break;
			}
			//Debug.Log(currTile.transform.position.x+" "+currTile.transform.position.y + "ClosedList: " + closedList.Count);
			//Debug.Log(currTile.transform.position.x+" "+currTile.transform.position.y + "F: " + currTile.F);
			steps++;

		}


		//Debug.Log(currTile.transform.position.x+" "+currTile.transform.position.y + " " + steps);
		while(currTile.G>0)
		{
			path.Add(currTile);
			if(closedList.Contains(currTile.North) && currTile.North!=null && currTile.North.G<currTile.G)
			{
				currTile=currTile.North;
			}
			else if(closedList.Contains(currTile.South) && currTile.South!=null && currTile.South.G<currTile.G)
			{
				currTile=currTile.South;
			}
			else if(closedList.Contains(currTile.East) && currTile.East!=null && currTile.East.G<currTile.G)
			{
				currTile=currTile.East;
			}
			else if(closedList.Contains(currTile.West) && currTile.West!=null && currTile.West.G<currTile.G)
			{
				currTile=currTile.West;
			}
			else{
				Debug.LogError("No tile adjacent!");
				Debug.Log(currTile);
				break;
			}
		}
		if (currTile==startTile)
		{
			//Debug.Log("Success");
			path.Reverse();
		}
	}
	
	/*private class ComparableTile : IComparable<ComparableTile>
	{
		public Tile tile;
		public ComparableTile north=null;
		public ComparableTile south=null;
		public ComparableTile east=null;
		public ComparableTile west=null;
		public int G;
		public int H{
			get{
				return(int)((tile.transform.position.x-Pathfinder.endTile.transform.position.x)+(tile.transform.position.y-Pathfinder.endTile.transform.position.y));
			}
		}
		public int F{
			get{
				return G+H;
			}
		}
		public ComparableTile(Tile tile, int G, HashSet<ComparableTile> closed)
		{
			this.tile=tile;
			this.G=G;
			foreach(ComparableTile t in closed)
			{
				if(t.tile.North!=null&&t.tile.North==this.tile)
				{
					t.north=this;
					this.south=t;
				}
				if(t.tile.South!=null&&t.tile.South==this.tile)
				{
					t.south=this;
					this.north=t;
				}
				if(t.tile.East!=null&&t.tile.East==this.tile)
				{
					t.east=this;
					this.west=t;
				}
				if(t.tile.West!=null&&t.tile.West==this.tile)
				{
					t.west=this;
					this.east=t;
				}
			}
		}
		public int CompareTo(ComparableTile other)
		{
			return F-other.F;
		}
	}*/
}
